/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.swcguild.librarymvc.model;

import java.math.BigDecimal;
import java.util.Date;
import java.util.Set;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

/**
 *
 * @author apprentice
 */
@Entity //marks classes as an "entity" for Hibernate - so the framework knows to look at it and keep track of it
@Table(name="books") //tells Hib that this class relates to the table "books" - will interpret this as a record for that table, and map it accordingly
                        //will map inserts and selects, etc. it addresses this entity as a table
public class HBook { //we also have to annotate each field as a column
    
    @Id //tell H it's our PRIMARY key
    @GeneratedValue //since it's a value generated by the DB, we tell H that
    @Column(name="book_id")
    private int bookId;
    
    @Column(name="isbn")
    private String isbn;
    
    @Column(name="title")
    private String title;
    
    //we will have a whole publisher, not just the id, why not get the whole thing if we can?
    //field we join on is participating in a many to one relatoinship, so we need to indicate this above the property
    @ManyToOne //we are in a book, I will many of one to them (have to step back and ask this Q)
    @JoinColumn(name="publisher_id") //where it's getting joined in the
    private Publisher publisher;
    
    //we will want a it to pull aset of authors for us  // when you ask for one or every book it will FETCH all of them - if we are eagerly fetching tihs can be expensive memory-wise
    @ManyToMany(fetch = FetchType.EAGER, cascade = {CascadeType.ALL}) //many authors to many books -- can choose to fetch either when referencing, or pull it out of the gate whether you want it or not
    @JoinTable(name="books_authors", //a bridge table annotation
                joinColumns={@JoinColumn(name="book_id")}, //our identifier/primary key, joinColumns actually takes an array that's why there are brackets, but we are only passing in one item (@annoation(attr="value"))
                inverseJoinColumns={@JoinColumn(name="author_id")}) //the related key   
    
    
    //we have a set of authur objects we are going to pull from teh rules above...so now we don't have to make a separate HAuthor DTO class
    private Set<Author> authors;
    
    @Column(name="price")  
    private BigDecimal price;
    
    @Column(name="publish_date")
    private Date publishDate; //Hibernate is only capable of dealing with Date, doesn't know what LocalDate is

    public int getBookId() {
        return bookId;
    }

    public void setBookId(int bookId) {
        this.bookId = bookId;
    }

    public String getIsbn() {
        return isbn;
    }

    public void setIsbn(String isbn) {
        this.isbn = isbn;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Publisher getPublisher() {
        return publisher;
    }

    public void setPublisher(Publisher publisher) {
        this.publisher = publisher;
    }

    public Set<Author> getAuthors() {
        return authors;
    }

    public void setAuthors(Set<Author> authors) {
        this.authors = authors;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Date getPublishDate() {
        return publishDate;
    }

    public void setPublishDate(Date publishDate) {
        this.publishDate = publishDate;
    }
    
    
    
}
